
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> options(digits=3)
> 
> library(pomp)
> 
> gompertz() -> po
> 
> pomp(po,partrans=NULL,userdata=list(bob=3),
+   covar=covariate_table(a=0:20,b=0:20,times="a")) -> po1
Warning message:
in 'pomp': the supplied covariate times do not embrace the data times: covariates may be extrapolated. 
> spy(po1)
==================
pomp object 'po1':

- data:
  - 100 records of 1 observable, recorded from t = 1 to 100 
  - summary of data:
       Y        
 Min.   :0.620  
 1st Qu.:0.943  
 Median :1.106  
 Mean   :1.134  
 3rd Qu.:1.325  
 Max.   :2.012  
- zero time, t0 = 0
- covariates: 
  - 21 records of 1 covariates, recorded from t = 0 to 20 
  - summary of covariates:
       b     
 Min.   : 0  
 1st Qu.: 5  
 Median :10  
 Mean   :10  
 3rd Qu.:15  
 Max.   :20  
- initial state simulator, rinit: <default>
- initial state density, dinit: <default>
- process-model simulator, rprocess: discrete-time process-model simulator
  - timestep = 1 
  - step.fun: native function
  - name: '_gompertz_step'
  - dynamically loaded from: 'pomp'
- process model density, dprocess: <default>
- measurement model simulator, rmeasure: native function
  - name: '_gompertz_normal_rmeasure'
  - dynamically loaded from: 'pomp'
- measurement model density, dmeasure: native function
  - name: '_gompertz_normal_dmeasure'
  - dynamically loaded from: 'pomp'
- measurement model expectation, emeasure: native function
  - name: '_gompertz_normal_emeasure'
  - dynamically loaded from: 'pomp'
- measurement model covariance, vmeasure: native function
  - name: '_gompertz_normal_vmeasure'
  - dynamically loaded from: 'pomp'
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: map:
  - timestep = 1 
  - native function
  - name: '_gompertz_skeleton'
  - dynamically loaded from: 'pomp'
- parameter vector:
    K     r sigma   tau   X_0 
  1.0   0.1   0.1   0.1   1.0 
- extra user-defined variables:
  - 'bob' (type 'double')


> 
> po1 |>
+   pomp(partrans=parameter_trans(log="r"),params=NULL,
+     rinit=function(params,t0,...)params,
+     paramnames="r",compile=FALSE,cfile="nancy") -> po2
Warning message:
in 'pomp': the supplied covariate times do not embrace the data times: covariates may be extrapolated. 
> spy(po2)
==================
pomp object 'po2':

- data:
  - 100 records of 1 observable, recorded from t = 1 to 100 
  - summary of data:
       Y        
 Min.   :0.620  
 1st Qu.:0.943  
 Median :1.106  
 Mean   :1.134  
 3rd Qu.:1.325  
 Max.   :2.012  
- zero time, t0 = 0
- covariates: 
  - 21 records of 1 covariates, recorded from t = 0 to 20 
  - summary of covariates:
       b     
 Min.   : 0  
 1st Qu.: 5  
 Median :10  
 Mean   :10  
 3rd Qu.:15  
 Max.   :20  
- initial state simulator, rinit: R function
  - definition: function (params, t0, ...) 
params

- initial state density, dinit: <default>
- process-model simulator, rprocess: discrete-time process-model simulator
  - timestep = 1 
  - step.fun: native function
  - name: '_gompertz_step'
  - dynamically loaded from: 'pomp'
- process model density, dprocess: <default>
- measurement model simulator, rmeasure: native function
  - name: '_gompertz_normal_rmeasure'
  - dynamically loaded from: 'pomp'
- measurement model density, dmeasure: native function
  - name: '_gompertz_normal_dmeasure'
  - dynamically loaded from: 'pomp'
- measurement model expectation, emeasure: native function
  - name: '_gompertz_normal_emeasure'
  - dynamically loaded from: 'pomp'
- measurement model covariance, vmeasure: native function
  - name: '_gompertz_normal_vmeasure'
  - dynamically loaded from: 'pomp'
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: map:
  - timestep = 1 
  - native function
  - name: '_gompertz_skeleton'
  - dynamically loaded from: 'pomp'
- parameter transformations:
  - to estimation scale: native function
  - name: '__pomp_to_trans'
  - defined by a C snippet in library 'nancy'
  - from estimation scale: native function
  - name: '__pomp_from_trans'
  - defined by a C snippet in library 'nancy'
- parameter vector unspecified
- extra user-defined variables:
  - 'bob' (type 'double')

- C snippet file  1 :


/* pomp C snippet file: nancy */
/* Time: 2025-03-19 22:22:43.356 -0400 */
/* Salt: 14A967C08D5AE20214B66811 */

#include <pomp.h>
#include <R_ext/Rdynload.h> 
 



/* C snippet: 'toEst' */

#define b (__covars[__covindex[0]])
#define r (__p[__parindex[0]])
#define T_r (__pt[__parindex[0]])
 
void __pomp_to_trans (double *__pt, const double *__p, const int *__parindex) { 
  T_r = log(r); 
}
 

#undef b
#undef r
#undef T_r

/* C snippet: 'fromEst' */

#define b (__covars[__covindex[0]])
#define r (__p[__parindex[0]])
#define T_r (__pt[__parindex[0]])
 
void __pomp_from_trans (double *__p, const double *__pt, const int *__parindex) { 
  r = exp(T_r); 
}
 

#undef b
#undef r
#undef T_r
static int __pomp_load_stack = 0;
void __pomp_load_stack_incr (void) {++__pomp_load_stack;}
void __pomp_load_stack_decr (int *val) {*val = --__pomp_load_stack;} 

 
void R_init_nancy (DllInfo *info) {
  R_RegisterCCallable("nancy", "__pomp_load_stack_incr", (DL_FUNC) __pomp_load_stack_incr);
  R_RegisterCCallable("nancy", "__pomp_load_stack_decr", (DL_FUNC) __pomp_load_stack_decr);
  R_RegisterCCallable("nancy", "__pomp_to_trans", (DL_FUNC) __pomp_to_trans);
  R_RegisterCCallable("nancy", "__pomp_from_trans", (DL_FUNC) __pomp_from_trans);
  

}
 
> 
> sir() -> sir
> spy(sir)
==================
pomp object 'sir':

- data:
  - 208 records of 1 observable, recorded from t = 0.0192 to 4 
  - summary of data:
    reports    
 Min.   :  44  
 1st Qu.: 151  
 Median : 246  
 Mean   : 448  
 3rd Qu.: 645  
 Max.   :2183  
- zero time, t0 = 0
- covariates: 
  - 421 records of 3 covariates, recorded from t = 0 to 4.2 
  - summary of covariates:
     seas_1          seas_2          seas_3     
 Min.   :0.042   Min.   :0.042   Min.   :0.042  
 1st Qu.:0.118   1st Qu.:0.122   1st Qu.:0.099  
 Median :0.335   Median :0.322   Median :0.289  
 Mean   :0.345   Mean   :0.334   Mean   :0.321  
 3rd Qu.:0.560   3rd Qu.:0.539   3rd Qu.:0.539  
 Max.   :0.667   Max.   :0.667   Max.   :0.667  
- initial state simulator, rinit: native function
  - name: '__pomp_rinit'
  - defined by a C snippet in library 'sir_source'
- initial state density, dinit: <default>
- process-model simulator, rprocess: Euler-method process-model simulator
  - timestep = 0.000962 
  - step.fun: native function
  - name: '__pomp_stepfn'
  - defined by a C snippet in library 'sir_source'
- process model density, dprocess: <default>
- measurement model simulator, rmeasure: native function
  - name: '__pomp_rmeasure'
  - defined by a C snippet in library 'sir_source'
- measurement model density, dmeasure: native function
  - name: '__pomp_dmeasure'
  - defined by a C snippet in library 'sir_source'
- measurement model expectation, emeasure: native function
  - name: '__pomp_emeasure'
  - defined by a C snippet in library 'sir_source'
- measurement model covariance, vmeasure: native function
  - name: '__pomp_vmeasure'
  - defined by a C snippet in library 'sir_source'
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: vectorfield:
  - native function
  - name: '__pomp_skelfn'
  - defined by a C snippet in library 'sir_source'
- parameter transformations:
  - to estimation scale: native function
  - name: '__pomp_to_trans'
  - defined by a C snippet in library 'sir_source'
  - from estimation scale: native function
  - name: '__pomp_from_trans'
  - defined by a C snippet in library 'sir_source'
- parameter vector:
   gamma       mu     iota    beta1    beta2    beta3  beta_sd      rho 
2.60e+01 2.00e-02 1.00e-02 4.00e+02 4.80e+02 3.20e+02 1.00e-03 6.00e-01 
       k      pop      S_0      I_0      R_0 
1.00e-01 2.10e+06 6.50e-02 1.00e-03 9.34e-01 

- C snippet file  1 :


/* pomp C snippet file: sir_source */
/* Time: 2025-03-19 22:22:43.502 -0400 */
/* Salt: 78BBB1D1EC302DA2B8D160A1 */

#include <pomp.h>
#include <R_ext/Rdynload.h> 

      static int nbasis = 3; 



/* C snippet: 'rinit' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
 
void __pomp_rinit (double *__x, const double *__p, double t,
   const int *__stateindex, const int *__parindex, const int *__covindex,
   const double *__covars) { 
      double m = pop/(S_0+I_0+R_0);
      S = nearbyint(m*S_0);
      I = nearbyint(m*I_0);
      R = nearbyint(m*R_0);
      cases = 0;
      W = 0; 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W

/* C snippet: 'step.fn' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
 
void __pomp_stepfn (double *__x, const double *__p, const int *__stateindex,
  const int *__parindex, const int *__covindex, const double *__covars,
  double t, double dt) { 
        int nrate = 6;
        double rate[nrate];               // transition rates
        double trans[nrate];            // transition numbers
        double beta;
        double dW;

        beta = dot_product(nbasis,&beta1,&seas_1);

        // gamma noise, mean=dt, variance=(beta_sd^2 dt)
        dW = rgammawn(beta_sd,dt);

        // compute the transition rates
        rate[0] = mu*pop;               // birth into susceptible class
        rate[1] = (iota+beta*I*dW/dt)/pop; // force of infection
        rate[2] = mu;                   // death from susceptible class
        rate[3] = gamma;        // recovery
        rate[4] = mu;                   // death from infectious class
        rate[5] = mu;           // death from recovered class

        // compute the transition numbers
        trans[0] = rpois(rate[0]*dt);   // births are Poisson
        reulermultinom(2,S,&rate[1],dt,&trans[1]);
        reulermultinom(2,I,&rate[3],dt,&trans[3]);
        reulermultinom(1,R,&rate[5],dt,&trans[5]);

        // balance the equations
        S += trans[0]-trans[1]-trans[2];
        I += trans[1]-trans[3]-trans[4];
        R += trans[3]-trans[5];
        cases += trans[3];              // cases are cumulative recoveries
        if (beta_sd > 0.0)  W += (dW-dt)/beta_sd; 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W

/* C snippet: 'rmeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
#define reports (__y[__obsindex[0]])
 
void __pomp_rmeasure (double *__y, const double *__x, const double *__p,
  const int *__obsindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, double t) { 
      reports = rnbinom_mu(1.0/k,cases*rho); 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W
#undef reports

/* C snippet: 'dmeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
#define reports (__y[__obsindex[0]])
#define lik (__lik[0])
 
void __pomp_dmeasure (double *__lik, const double *__y, const double *__x,
  const double *__p, int give_log, const int *__obsindex,
  const int *__stateindex, const int *__parindex, const int *__covindex,
  const double *__covars, double t) { 
      lik = dnbinom_mu(nearbyint(reports),1.0/k,cases*rho,give_log); 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W
#undef reports
#undef lik

/* C snippet: 'emeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
#define E_reports (__f[__obsindex[0]])
 
void __pomp_emeasure (double *__f, const double *__x, const double *__p,
  const int *__obsindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, double t) { 
      E_reports = cases*rho; 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W
#undef E_reports

/* C snippet: 'vmeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
#define V_reports_reports (__f[__vmatindex[0]])
 
void __pomp_vmeasure (double *__f, const double *__x, const double *__p,
  const int *__vmatindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, int nobs, double t) { 
      double mean = cases*rho;
      V_reports_reports = mean*(1+k*mean); 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W
#undef V_reports_reports

/* C snippet: 'toEst' */

#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define T_gamma (__pt[__parindex[0]])
#define T_mu (__pt[__parindex[1]])
#define T_iota (__pt[__parindex[2]])
#define T_beta1 (__pt[__parindex[3]])
#define T_beta_sd (__pt[__parindex[4]])
#define T_pop (__pt[__parindex[5]])
#define T_rho (__pt[__parindex[6]])
#define T_k (__pt[__parindex[7]])
#define T_S_0 (__pt[__parindex[8]])
#define T_I_0 (__pt[__parindex[9]])
#define T_R_0 (__pt[__parindex[10]])
 
void __pomp_to_trans (double *__pt, const double *__p, const int *__parindex) { 
        int j;
        const double *BETA = &beta1;
        double *TBETA = &T_beta1;
        for (j = 0; j < nbasis; j++) TBETA[j] = log(BETA[j]);

  T_gamma = log(gamma);
  T_mu = log(mu);
  T_iota = log(iota);
  T_beta_sd = log(beta_sd);
  T_k = log(k);
  T_rho = logit(rho);
  to_log_barycentric(&T_S_0,&S_0,3); 
}
 

#undef seas_1
#undef seas_2
#undef seas_3
#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef T_gamma
#undef T_mu
#undef T_iota
#undef T_beta1
#undef T_beta_sd
#undef T_pop
#undef T_rho
#undef T_k
#undef T_S_0
#undef T_I_0
#undef T_R_0

/* C snippet: 'fromEst' */

#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define T_gamma (__pt[__parindex[0]])
#define T_mu (__pt[__parindex[1]])
#define T_iota (__pt[__parindex[2]])
#define T_beta1 (__pt[__parindex[3]])
#define T_beta_sd (__pt[__parindex[4]])
#define T_pop (__pt[__parindex[5]])
#define T_rho (__pt[__parindex[6]])
#define T_k (__pt[__parindex[7]])
#define T_S_0 (__pt[__parindex[8]])
#define T_I_0 (__pt[__parindex[9]])
#define T_R_0 (__pt[__parindex[10]])
 
void __pomp_from_trans (double *__p, const double *__pt, const int *__parindex) { 
        int j;
        const double *TBETA = &T_beta1;
        double *BETA = &beta1;
        for (j = 0; j < nbasis; j++) BETA[j] = exp(TBETA[j]);

  gamma = exp(T_gamma);
  mu = exp(T_mu);
  iota = exp(T_iota);
  beta_sd = exp(T_beta_sd);
  k = exp(T_k);
  rho = expit(T_rho);
  from_log_barycentric(&S_0,&T_S_0,3); 
}
 

#undef seas_1
#undef seas_2
#undef seas_3
#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef T_gamma
#undef T_mu
#undef T_iota
#undef T_beta1
#undef T_beta_sd
#undef T_pop
#undef T_rho
#undef T_k
#undef T_S_0
#undef T_I_0
#undef T_R_0

/* C snippet: 'skeleton' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define beta1 (__p[__parindex[3]])
#define beta_sd (__p[__parindex[4]])
#define pop (__p[__parindex[5]])
#define rho (__p[__parindex[6]])
#define k (__p[__parindex[7]])
#define S_0 (__p[__parindex[8]])
#define I_0 (__p[__parindex[9]])
#define R_0 (__p[__parindex[10]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define cases (__x[__stateindex[3]])
#define W (__x[__stateindex[4]])
#define DS (__f[__stateindex[0]])
#define DI (__f[__stateindex[1]])
#define DR (__f[__stateindex[2]])
#define Dcases (__f[__stateindex[3]])
#define DW (__f[__stateindex[4]])
 
void __pomp_skelfn (double *__f, const double *__x, const double *__p,
  const int *__stateindex, const int *__parindex, const int *__covindex,
  const double *__covars, double t) { 
      int nrate = 6;
      double rate[nrate];                 // transition rates
      double term[nrate];               // terms in the equations
      double beta;
      double dW;

      beta = dot_product(nbasis,&beta1,&seas_1);

      // compute the transition rates
      rate[0] = mu*pop;         // birth into susceptible class
      rate[1] = (iota+beta*I)/pop; // force of infection
      rate[2] = mu;                     // death from susceptible class
      rate[3] = gamma;  // recovery
      rate[4] = mu;                     // death from infectious class
      rate[5] = mu;             // death from recovered class

      // compute the several terms
      term[0] = rate[0];
      term[1] = rate[1]*S;
      term[2] = rate[2]*S;
      term[3] = rate[3]*I;
      term[4] = rate[4]*I;
      term[5] = rate[5]*R;

      // balance the equations
      DS = term[0]-term[1]-term[2];
      DI = term[1]-term[3]-term[4];
      DR = term[3]-term[5];
      Dcases = term[3];         // accumulate the new I->R transitions
      DW = 0;                   // no noise, so no noise accumulation 
}
 

#undef gamma
#undef mu
#undef iota
#undef beta1
#undef beta_sd
#undef pop
#undef rho
#undef k
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef cases
#undef W
#undef DS
#undef DI
#undef DR
#undef Dcases
#undef DW
static int __pomp_load_stack = 0;
void __pomp_load_stack_incr (void) {++__pomp_load_stack;}
void __pomp_load_stack_decr (int *val) {*val = --__pomp_load_stack;} 

 
void R_init_sir_source (DllInfo *info) {
  R_RegisterCCallable("sir_source", "__pomp_load_stack_incr", (DL_FUNC) __pomp_load_stack_incr);
  R_RegisterCCallable("sir_source", "__pomp_load_stack_decr", (DL_FUNC) __pomp_load_stack_decr);
  R_RegisterCCallable("sir_source", "__pomp_rinit", (DL_FUNC) __pomp_rinit);
  R_RegisterCCallable("sir_source", "__pomp_stepfn", (DL_FUNC) __pomp_stepfn);
  R_RegisterCCallable("sir_source", "__pomp_rmeasure", (DL_FUNC) __pomp_rmeasure);
  R_RegisterCCallable("sir_source", "__pomp_dmeasure", (DL_FUNC) __pomp_dmeasure);
  R_RegisterCCallable("sir_source", "__pomp_emeasure", (DL_FUNC) __pomp_emeasure);
  R_RegisterCCallable("sir_source", "__pomp_vmeasure", (DL_FUNC) __pomp_vmeasure);
  R_RegisterCCallable("sir_source", "__pomp_to_trans", (DL_FUNC) __pomp_to_trans);
  R_RegisterCCallable("sir_source", "__pomp_from_trans", (DL_FUNC) __pomp_from_trans);
  R_RegisterCCallable("sir_source", "__pomp_skelfn", (DL_FUNC) __pomp_skelfn);
  

}
 
> 
> rw2() -> rw2
> spy(rw2)
==================
pomp object 'rw2':

- data:
  - 100 records of 2 observables, recorded from t = 1 to 100 
  - summary of data:
       y1               y2        
 Min.   :-16.93   Min.   :-13.86  
 1st Qu.:-11.45   1st Qu.: -4.57  
 Median : -4.15   Median : -1.74  
 Mean   : -5.81   Mean   : -0.92  
 3rd Qu.: -1.30   3rd Qu.:  3.07  
 Max.   :  3.50   Max.   : 10.26  
- zero time, t0 = 0
- covariates: <none>
- initial state simulator, rinit: <default>
- initial state density, dinit: <default>
- process-model simulator, rprocess: one-step process-model simulator
  - step.fun: native function
  - name: '__pomp_stepfn'
  - defined by a C snippet in library 'rw2_source'
- process model density, dprocess: native function
  - name: '__pomp_dproc'
  - defined by a C snippet in library 'rw2_source'
- measurement model simulator, rmeasure: native function
  - name: '__pomp_rmeasure'
  - defined by a C snippet in library 'rw2_source'
- measurement model density, dmeasure: native function
  - name: '__pomp_dmeasure'
  - defined by a C snippet in library 'rw2_source'
- measurement model expectation, emeasure: native function
  - name: '__pomp_emeasure'
  - defined by a C snippet in library 'rw2_source'
- measurement model covariance, vmeasure: native function
  - name: '__pomp_vmeasure'
  - defined by a C snippet in library 'rw2_source'
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: <default>

- parameter vector:
x1_0 x2_0   s1   s2  tau 
   0    0    1    3    1 

- C snippet file  1 :


/* pomp C snippet file: rw2_source */
/* Time: 2025-03-19 22:22:44.296 -0400 */
/* Salt: 630B75886390C17C8AEE5220 */

#include <pomp.h>
#include <R_ext/Rdynload.h> 
 



/* C snippet: 'step.fn' */

#define s1 (__p[__parindex[0]])
#define s2 (__p[__parindex[1]])
#define tau (__p[__parindex[2]])
#define x1 (__x[__stateindex[0]])
#define x2 (__x[__stateindex[1]])
 
void __pomp_stepfn (double *__x, const double *__p, const int *__stateindex,
  const int *__parindex, const int *__covindex, const double *__covars,
  double t, double dt) { 
        x1 = rnorm(x1,s1*sqrt(dt));
        x2 = rnorm(x2,s2*sqrt(dt)); 
}
 

#undef s1
#undef s2
#undef tau
#undef x1
#undef x2

/* C snippet: 'dprocess' */

#define s1 (__p[__parindex[0]])
#define s2 (__p[__parindex[1]])
#define tau (__p[__parindex[2]])
#define x1_1 (__x1[__stateindex[0]])
#define x2_1 (__x1[__stateindex[1]])
#define x1_2 (__x2[__stateindex[0]])
#define x2_2 (__x2[__stateindex[1]])
#define loglik (__loglik[0])
 
void __pomp_dproc (double *__loglik, const double *__x1, const double *__x2,
  double t_1, double t_2, const double *__p, const int *__stateindex,
  const int *__parindex, const int *__covindex, const double *__covars) { 
        double sdt = sqrt(t_2 - t_1);
        loglik = dnorm(x1_2,x1_1,s1*sdt,1)+
        dnorm(x2_2,x2_1,s2*sdt,1); 
}
 

#undef s1
#undef s2
#undef tau
#undef x1_1
#undef x2_1
#undef x1_2
#undef x2_2
#undef loglik

/* C snippet: 'rmeasure' */

#define s1 (__p[__parindex[0]])
#define s2 (__p[__parindex[1]])
#define tau (__p[__parindex[2]])
#define x1 (__x[__stateindex[0]])
#define x2 (__x[__stateindex[1]])
#define y1 (__y[__obsindex[0]])
#define y2 (__y[__obsindex[1]])
 
void __pomp_rmeasure (double *__y, const double *__x, const double *__p,
  const int *__obsindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, double t) { 
        y1 = rnorm(x1,tau);
        y2 = rnorm(x2,tau); 
}
 

#undef s1
#undef s2
#undef tau
#undef x1
#undef x2
#undef y1
#undef y2

/* C snippet: 'dmeasure' */

#define s1 (__p[__parindex[0]])
#define s2 (__p[__parindex[1]])
#define tau (__p[__parindex[2]])
#define x1 (__x[__stateindex[0]])
#define x2 (__x[__stateindex[1]])
#define y1 (__y[__obsindex[0]])
#define y2 (__y[__obsindex[1]])
#define lik (__lik[0])
 
void __pomp_dmeasure (double *__lik, const double *__y, const double *__x,
  const double *__p, int give_log, const int *__obsindex,
  const int *__stateindex, const int *__parindex, const int *__covindex,
  const double *__covars, double t) { 
        lik = dnorm(y1,x1,tau,1)+dnorm(y2,x2,tau,1);
        lik = (give_log) ? lik : exp(lik); 
}
 

#undef s1
#undef s2
#undef tau
#undef x1
#undef x2
#undef y1
#undef y2
#undef lik

/* C snippet: 'emeasure' */

#define s1 (__p[__parindex[0]])
#define s2 (__p[__parindex[1]])
#define tau (__p[__parindex[2]])
#define x1 (__x[__stateindex[0]])
#define x2 (__x[__stateindex[1]])
#define E_y1 (__f[__obsindex[0]])
#define E_y2 (__f[__obsindex[1]])
 
void __pomp_emeasure (double *__f, const double *__x, const double *__p,
  const int *__obsindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, double t) { 
        E_y1 = x1;
        E_y2 = x2; 
}
 

#undef s1
#undef s2
#undef tau
#undef x1
#undef x2
#undef E_y1
#undef E_y2

/* C snippet: 'vmeasure' */

#define s1 (__p[__parindex[0]])
#define s2 (__p[__parindex[1]])
#define tau (__p[__parindex[2]])
#define x1 (__x[__stateindex[0]])
#define x2 (__x[__stateindex[1]])
#define V_y1_y1 (__f[__vmatindex[0]])
#define V_y2_y1 (__f[__vmatindex[1]])
#define V_y1_y2 (__f[__vmatindex[2]])
#define V_y2_y2 (__f[__vmatindex[3]])
 
void __pomp_vmeasure (double *__f, const double *__x, const double *__p,
  const int *__vmatindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, int nobs, double t) { 
        V_y1_y1 = V_y2_y2 = tau*tau;
        V_y1_y2 = V_y2_y1 = 0; 
}
 

#undef s1
#undef s2
#undef tau
#undef x1
#undef x2
#undef V_y1_y1
#undef V_y2_y1
#undef V_y1_y2
#undef V_y2_y2
static int __pomp_load_stack = 0;
void __pomp_load_stack_incr (void) {++__pomp_load_stack;}
void __pomp_load_stack_decr (int *val) {*val = --__pomp_load_stack;} 

 
void R_init_rw2_source (DllInfo *info) {
  R_RegisterCCallable("rw2_source", "__pomp_load_stack_incr", (DL_FUNC) __pomp_load_stack_incr);
  R_RegisterCCallable("rw2_source", "__pomp_load_stack_decr", (DL_FUNC) __pomp_load_stack_decr);
  R_RegisterCCallable("rw2_source", "__pomp_stepfn", (DL_FUNC) __pomp_stepfn);
  R_RegisterCCallable("rw2_source", "__pomp_dproc", (DL_FUNC) __pomp_dproc);
  R_RegisterCCallable("rw2_source", "__pomp_rmeasure", (DL_FUNC) __pomp_rmeasure);
  R_RegisterCCallable("rw2_source", "__pomp_dmeasure", (DL_FUNC) __pomp_dmeasure);
  R_RegisterCCallable("rw2_source", "__pomp_emeasure", (DL_FUNC) __pomp_emeasure);
  R_RegisterCCallable("rw2_source", "__pomp_vmeasure", (DL_FUNC) __pomp_vmeasure);
  

}
 
> 
> sir2() -> sir2
> spy(sir2)
==================
pomp object 'sir2':

- data:
  - 120 records of 1 observable, recorded from t = 0.0833 to 10 
  - summary of data:
    reports   
 Min.   :  0  
 1st Qu.:  5  
 Median : 18  
 Mean   :110  
 3rd Qu.:151  
 Max.   :876  
- zero time, t0 = 0
- covariates: 
  - 1021 records of 3 covariates, recorded from t = 0 to 10.2 
  - summary of covariates:
     seas_1          seas_2          seas_3     
 Min.   :0.042   Min.   :0.042   Min.   :0.042  
 1st Qu.:0.118   1st Qu.:0.114   1st Qu.:0.103  
 Median :0.335   Median :0.322   Median :0.302  
 Mean   :0.338   Mean   :0.334   Mean   :0.328  
 3rd Qu.:0.560   3rd Qu.:0.550   3rd Qu.:0.550  
 Max.   :0.667   Max.   :0.667   Max.   :0.667  
- initial state simulator, rinit: native function
  - name: '__pomp_rinit'
  - defined by a C snippet in library 'sir2_source'
- initial state density, dinit: <default>
- process-model simulator, rprocess: Gillespie-method process-model simulator
  - stoichiometry matrix:
       event
name    birth susc.death infection inf.death recovery recov.death
  S         1         -1        -1         0        0           0
  I         0          0         1        -1       -1           0
  R         0          0         0         0        1          -1
  N         1         -1         0        -1        0          -1
  cases     0          0         0         0        1           0
  - rate.fun: native function
  - name: '__pomp_ratefn'
  - defined by a C snippet in library 'sir2_source'
- process model density, dprocess: <default>
- measurement model simulator, rmeasure: native function
  - name: '__pomp_rmeasure'
  - defined by a C snippet in library 'sir2_source'
- measurement model density, dmeasure: native function
  - name: '__pomp_dmeasure'
  - defined by a C snippet in library 'sir2_source'
- measurement model expectation, emeasure: native function
  - name: '__pomp_emeasure'
  - defined by a C snippet in library 'sir2_source'
- measurement model covariance, vmeasure: native function
  - name: '__pomp_vmeasure'
  - defined by a C snippet in library 'sir2_source'
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: vectorfield:
  - native function
  - name: '__pomp_skelfn'
  - defined by a C snippet in library 'sir2_source'
- parameter transformations:
  - to estimation scale: native function
  - name: '__pomp_to_trans'
  - defined by a C snippet in library 'sir2_source'
  - from estimation scale: native function
  - name: '__pomp_from_trans'
  - defined by a C snippet in library 'sir2_source'
- parameter vector:
   gamma       mu     iota      rho        k    beta1    beta2    beta3 
2.40e+01 1.43e-02 1.00e-01 1.00e-01 1.00e-01 3.30e+02 4.10e+02 4.90e+02 
     S_0      I_0      R_0      pop 
5.00e-02 1.00e-04 9.50e-01 1.00e+06 

- C snippet file  1 :


/* pomp C snippet file: sir2_source */
/* Time: 2025-03-19 22:22:44.976 -0400 */
/* Salt: 7DB3D7473B47BA1FE083CC7B */

#include <pomp.h>
#include <R_ext/Rdynload.h> 
static int nbasis = 3; 



/* C snippet: 'rinit' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
 
void __pomp_rinit (double *__x, const double *__p, double t,
   const int *__stateindex, const int *__parindex, const int *__covindex,
   const double *__covars) { 
      double m;
      m = pop/(S_0+I_0+R_0);
      S = nearbyint(m*S_0);
      I = nearbyint(m*I_0);
      N = nearbyint(pop);
      R = nearbyint(m*R_0);
      cases = 0; 
}
 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases

/* C snippet: 'rate.fn' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
 
double __pomp_ratefn (int j, double t, double *__x, const double *__p,
  const int *__stateindex, const int *__parindex, const int *__covindex,
  const double *__covars) {
  double rate = 0.0; double beta;
switch (j) {
case 1:
{
rate = mu*pop;
}
break;

case 2:
{
rate = mu*S;
}
break;

case 3:
{

      beta = dot_product(nbasis,&beta1,&seas_1);
      rate = (beta*I+iota)*S/pop;
}
break;

case 4:
{
rate = mu*I;
}
break;

case 5:
{
rate = gamma*I;
}
break;

case 6:
{
rate = mu*R;
}
break;

default:
error("unrecognized event %d",j);
break;
}
 
  return rate;
} 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases

/* C snippet: 'rmeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
#define reports (__y[__obsindex[0]])
 
void __pomp_rmeasure (double *__y, const double *__x, const double *__p,
  const int *__obsindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, double t) { 
      reports = rnbinom_mu(1.0/k,cases*rho); 
}
 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases
#undef reports

/* C snippet: 'dmeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
#define reports (__y[__obsindex[0]])
#define lik (__lik[0])
 
void __pomp_dmeasure (double *__lik, const double *__y, const double *__x,
  const double *__p, int give_log, const int *__obsindex,
  const int *__stateindex, const int *__parindex, const int *__covindex,
  const double *__covars, double t) { 
      lik = dnbinom_mu(nearbyint(reports),1.0/k,cases*rho,give_log); 
}
 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases
#undef reports
#undef lik

/* C snippet: 'emeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
#define E_reports (__f[__obsindex[0]])
 
void __pomp_emeasure (double *__f, const double *__x, const double *__p,
  const int *__obsindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, double t) { 
      E_reports = cases*rho; 
}
 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases
#undef E_reports

/* C snippet: 'vmeasure' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
#define V_reports_reports (__f[__vmatindex[0]])
 
void __pomp_vmeasure (double *__f, const double *__x, const double *__p,
  const int *__vmatindex, const int *__stateindex, const int *__parindex,
  const int *__covindex, const double *__covars, int nobs, double t) { 
      double mean = cases*rho;
      V_reports_reports = mean*(1+k*mean); 
}
 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases
#undef V_reports_reports

/* C snippet: 'toEst' */

#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define T_gamma (__pt[__parindex[0]])
#define T_mu (__pt[__parindex[1]])
#define T_iota (__pt[__parindex[2]])
#define T_pop (__pt[__parindex[3]])
#define T_rho (__pt[__parindex[4]])
#define T_k (__pt[__parindex[5]])
#define T_beta1 (__pt[__parindex[6]])
#define T_beta2 (__pt[__parindex[7]])
#define T_beta3 (__pt[__parindex[8]])
#define T_S_0 (__pt[__parindex[9]])
#define T_I_0 (__pt[__parindex[10]])
#define T_R_0 (__pt[__parindex[11]])
 
void __pomp_to_trans (double *__pt, const double *__p, const int *__parindex) { 
  T_gamma = log(gamma);
  T_mu = log(mu);
  T_iota = log(iota);
  T_k = log(k);
  T_beta1 = log(beta1);
  T_beta2 = log(beta2);
  T_beta3 = log(beta3);
  T_rho = logit(rho);
  to_log_barycentric(&T_S_0,&S_0,3); 
}
 

#undef seas_1
#undef seas_2
#undef seas_3
#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef T_gamma
#undef T_mu
#undef T_iota
#undef T_pop
#undef T_rho
#undef T_k
#undef T_beta1
#undef T_beta2
#undef T_beta3
#undef T_S_0
#undef T_I_0
#undef T_R_0

/* C snippet: 'fromEst' */

#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define T_gamma (__pt[__parindex[0]])
#define T_mu (__pt[__parindex[1]])
#define T_iota (__pt[__parindex[2]])
#define T_pop (__pt[__parindex[3]])
#define T_rho (__pt[__parindex[4]])
#define T_k (__pt[__parindex[5]])
#define T_beta1 (__pt[__parindex[6]])
#define T_beta2 (__pt[__parindex[7]])
#define T_beta3 (__pt[__parindex[8]])
#define T_S_0 (__pt[__parindex[9]])
#define T_I_0 (__pt[__parindex[10]])
#define T_R_0 (__pt[__parindex[11]])
 
void __pomp_from_trans (double *__p, const double *__pt, const int *__parindex) { 
  gamma = exp(T_gamma);
  mu = exp(T_mu);
  iota = exp(T_iota);
  k = exp(T_k);
  beta1 = exp(T_beta1);
  beta2 = exp(T_beta2);
  beta3 = exp(T_beta3);
  rho = expit(T_rho);
  from_log_barycentric(&S_0,&T_S_0,3); 
}
 

#undef seas_1
#undef seas_2
#undef seas_3
#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef T_gamma
#undef T_mu
#undef T_iota
#undef T_pop
#undef T_rho
#undef T_k
#undef T_beta1
#undef T_beta2
#undef T_beta3
#undef T_S_0
#undef T_I_0
#undef T_R_0

/* C snippet: 'skeleton' */

#define gamma (__p[__parindex[0]])
#define mu (__p[__parindex[1]])
#define iota (__p[__parindex[2]])
#define pop (__p[__parindex[3]])
#define rho (__p[__parindex[4]])
#define k (__p[__parindex[5]])
#define beta1 (__p[__parindex[6]])
#define beta2 (__p[__parindex[7]])
#define beta3 (__p[__parindex[8]])
#define S_0 (__p[__parindex[9]])
#define I_0 (__p[__parindex[10]])
#define R_0 (__p[__parindex[11]])
#define seas_1 (__covars[__covindex[0]])
#define seas_2 (__covars[__covindex[1]])
#define seas_3 (__covars[__covindex[2]])
#define S (__x[__stateindex[0]])
#define I (__x[__stateindex[1]])
#define R (__x[__stateindex[2]])
#define N (__x[__stateindex[3]])
#define cases (__x[__stateindex[4]])
#define DS (__f[__stateindex[0]])
#define DI (__f[__stateindex[1]])
#define DR (__f[__stateindex[2]])
#define DN (__f[__stateindex[3]])
#define Dcases (__f[__stateindex[4]])
 
void __pomp_skelfn (double *__f, const double *__x, const double *__p,
  const int *__stateindex, const int *__parindex, const int *__covindex,
  const double *__covars, double t) { 
        int nrate = 6;
        double rate[nrate];
        double term[nrate];
        double beta;

        beta = dot_product(nbasis,&beta1,&seas_1);

        rate[0] = mu*pop;
        rate[1] = (iota+beta*I)/pop;
        rate[2] = mu;
        rate[3] = gamma;
        rate[4] = mu;
        rate[5] = mu;

        term[0] = rate[0];
        term[1] = rate[1]*S;
        term[2] = rate[2]*S;
        term[3] = rate[3]*I;
        term[4] = rate[4]*I;
        term[5] = rate[5]*R;

        DS = term[0]-term[1]-term[2];
        DI = term[1]-term[3]-term[4];
        DR = term[3]-term[5];
        DN = term[0]-term[2]-term[4]-term[5];
        Dcases = term[3]; 
}
 

#undef gamma
#undef mu
#undef iota
#undef pop
#undef rho
#undef k
#undef beta1
#undef beta2
#undef beta3
#undef S_0
#undef I_0
#undef R_0
#undef seas_1
#undef seas_2
#undef seas_3
#undef S
#undef I
#undef R
#undef N
#undef cases
#undef DS
#undef DI
#undef DR
#undef DN
#undef Dcases
static int __pomp_load_stack = 0;
void __pomp_load_stack_incr (void) {++__pomp_load_stack;}
void __pomp_load_stack_decr (int *val) {*val = --__pomp_load_stack;} 

 
void R_init_sir2_source (DllInfo *info) {
  R_RegisterCCallable("sir2_source", "__pomp_load_stack_incr", (DL_FUNC) __pomp_load_stack_incr);
  R_RegisterCCallable("sir2_source", "__pomp_load_stack_decr", (DL_FUNC) __pomp_load_stack_decr);
  R_RegisterCCallable("sir2_source", "__pomp_rinit", (DL_FUNC) __pomp_rinit);
  R_RegisterCCallable("sir2_source", "__pomp_ratefn", (DL_FUNC) __pomp_ratefn);
  R_RegisterCCallable("sir2_source", "__pomp_rmeasure", (DL_FUNC) __pomp_rmeasure);
  R_RegisterCCallable("sir2_source", "__pomp_dmeasure", (DL_FUNC) __pomp_dmeasure);
  R_RegisterCCallable("sir2_source", "__pomp_emeasure", (DL_FUNC) __pomp_emeasure);
  R_RegisterCCallable("sir2_source", "__pomp_vmeasure", (DL_FUNC) __pomp_vmeasure);
  R_RegisterCCallable("sir2_source", "__pomp_to_trans", (DL_FUNC) __pomp_to_trans);
  R_RegisterCCallable("sir2_source", "__pomp_from_trans", (DL_FUNC) __pomp_from_trans);
  R_RegisterCCallable("sir2_source", "__pomp_skelfn", (DL_FUNC) __pomp_skelfn);
  

}
 
> 
> try(spy())
Error : in 'spy': 'object' is a required argument.
> try(spy(list()))
Error : 'spy' is undefined for 'object' of class 'list'.
> 
> pomp(
+   data=NULL,
+   t0=0,times=1:10,
+   userdata=list(x0=as.double(1)),
+   params=c(x_0=1,a=22),
+   rinit=Csnippet(r"{x = *get_userdata_double("x0");}"),
+   statenames="x",
+   compile=FALSE
+ ) |>
+   spy()
==================
pomp object 'pomp(data = NULL, t0 = 0, times = 1:10, userdata = list(x0 = as.double(1)), ''    params = c(x_0 = 1, a = 22), rinit = Csnippet("x = *get_userdata_double(\"x0\");"), ''    statenames = "x", compile = FALSE)':

- data: <none>
- zero time, t0 = 0
- covariates: <none>
- initial state simulator, rinit: native function
  - name: '__pomp_rinit'
  - defined by a C snippet in library 'pomp_b34a9ad2328d2598c3c1cd4ae40c4bb3'
- initial state density, dinit: <default>
- process-model simulator, rprocess: <undefined>
- process model density, dprocess: <default>
- measurement model simulator, rmeasure: <default>
- measurement model density, dmeasure: <default>
- measurement model expectation, emeasure: <default>
- measurement model covariance, vmeasure: <default>
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: <default>

- parameter vector:
x_0   a 
  1  22 
- extra user-defined variables:
  - 'x0' (type 'double')

- C snippet file  1 :


/* pomp C snippet file: pomp_b34a9ad2328d2598c3c1cd4ae40c4bb3 */
/* Time: 2025-03-19 22:22:45.787 -0400 */
/* Salt: 2F65637D1998952097298F5D */

#include <pomp.h>
#include <R_ext/Rdynload.h> 
 


static get_userdata_double_t *__pomp_get_userdata_double;
#define get_userdata_double(X)  (__pomp_get_userdata_double(X))

/* C snippet: 'rinit' */

#define x (__x[__stateindex[0]])
 
void __pomp_rinit (double *__x, const double *__p, double t,
   const int *__stateindex, const int *__parindex, const int *__covindex,
   const double *__covars) { x = *get_userdata_double("x0"); 
}
 

#undef x
static int __pomp_load_stack = 0;
void __pomp_load_stack_incr (void) {++__pomp_load_stack;}
void __pomp_load_stack_decr (int *val) {*val = --__pomp_load_stack;} 

 
void R_init_pomp_b34a9ad2328d2598c3c1cd4ae40c4bb3 (DllInfo *info) {
  __pomp_get_userdata_double = (get_userdata_double_t *) R_GetCCallable("pomp","get_userdata_double");
  R_RegisterCCallable("pomp_b34a9ad2328d2598c3c1cd4ae40c4bb3", "__pomp_load_stack_incr", (DL_FUNC) __pomp_load_stack_incr);
  R_RegisterCCallable("pomp_b34a9ad2328d2598c3c1cd4ae40c4bb3", "__pomp_load_stack_decr", (DL_FUNC) __pomp_load_stack_decr);
  R_RegisterCCallable("pomp_b34a9ad2328d2598c3c1cd4ae40c4bb3", "__pomp_rinit", (DL_FUNC) __pomp_rinit);
  

}
 
> 
> pomp(
+   data=NULL,
+   t0=0,times=1:10,
+   userdata=list(x0=as.double(1)),
+   params=c(x_0=1,a=22),
+   globals=Csnippet("static double X0;"),
+   rinit=Csnippet(r"{x = X0;}"),
+   rprocess=euler(Csnippet(r"(x += rgammawn(0.1,dt);)"),delta.t=0.1),
+   on_load=Csnippet(r"{X0 = *get_userdata_double("x0");}"),
+   statenames="x",
+   compile=FALSE
+ ) |>
+   spy()
==================
pomp object 'pomp(data = NULL, t0 = 0, times = 1:10, userdata = list(x0 = as.double(1)), ''    params = c(x_0 = 1, a = 22), globals = Csnippet("static double X0;"), ''    rinit = Csnippet("x = X0;"), rprocess = euler(Csnippet("x += rgammawn(0.1,dt);"), ''        delta.t = 0.1), on_load = Csnippet("X0 = *get_userdata_double(\"x0\");"), ''    statenames = "x", compile = FALSE)':

- data: <none>
- zero time, t0 = 0
- covariates: <none>
- initial state simulator, rinit: native function
  - name: '__pomp_rinit'
  - defined by a C snippet in library 'pomp_9a9df2d3acfc2860dcc63f8865a4e0d9'
- initial state density, dinit: <default>
- process-model simulator, rprocess: Euler-method process-model simulator
  - timestep = 0.1 
  - step.fun: native function
  - name: '__pomp_stepfn'
  - defined by a C snippet in library 'pomp_9a9df2d3acfc2860dcc63f8865a4e0d9'
- process model density, dprocess: <default>
- measurement model simulator, rmeasure: <default>
- measurement model density, dmeasure: <default>
- measurement model expectation, emeasure: <default>
- measurement model covariance, vmeasure: <default>
- prior simulator, rprior: <default>
- prior density, dprior: <default>
- deterministic skeleton: <default>

- parameter vector:
x_0   a 
  1  22 
- extra user-defined variables:
  - 'x0' (type 'double')

- C snippet file  1 :


/* pomp C snippet file: pomp_9a9df2d3acfc2860dcc63f8865a4e0d9 */
/* Time: 2025-03-19 22:22:45.840 -0400 */
/* Salt: E726F32B12E50B088F3CA8F4 */

#include <pomp.h>
#include <R_ext/Rdynload.h> 
static double X0; 


static get_userdata_double_t *__pomp_get_userdata_double;
#define get_userdata_double(X)  (__pomp_get_userdata_double(X))

/* C snippet: 'rinit' */

#define x (__x[__stateindex[0]])
 
void __pomp_rinit (double *__x, const double *__p, double t,
   const int *__stateindex, const int *__parindex, const int *__covindex,
   const double *__covars) { x = X0; 
}
 

#undef x

/* C snippet: 'step.fn' */

#define x (__x[__stateindex[0]])
 
void __pomp_stepfn (double *__x, const double *__p, const int *__stateindex,
  const int *__parindex, const int *__covindex, const double *__covars,
  double t, double dt) { x += rgammawn(0.1,dt); 
}
 

#undef x
static int __pomp_load_stack = 0;
void __pomp_load_stack_incr (void) {++__pomp_load_stack;}
void __pomp_load_stack_decr (int *val) {*val = --__pomp_load_stack;} 

 
void R_init_pomp_9a9df2d3acfc2860dcc63f8865a4e0d9 (DllInfo *info) {
  __pomp_get_userdata_double = (get_userdata_double_t *) R_GetCCallable("pomp","get_userdata_double");
  R_RegisterCCallable("pomp_9a9df2d3acfc2860dcc63f8865a4e0d9", "__pomp_load_stack_incr", (DL_FUNC) __pomp_load_stack_incr);
  R_RegisterCCallable("pomp_9a9df2d3acfc2860dcc63f8865a4e0d9", "__pomp_load_stack_decr", (DL_FUNC) __pomp_load_stack_decr);
  R_RegisterCCallable("pomp_9a9df2d3acfc2860dcc63f8865a4e0d9", "__pomp_rinit", (DL_FUNC) __pomp_rinit);
  R_RegisterCCallable("pomp_9a9df2d3acfc2860dcc63f8865a4e0d9", "__pomp_stepfn", (DL_FUNC) __pomp_stepfn);
 X0 = *get_userdata_double("x0"); 

}
 
> 
